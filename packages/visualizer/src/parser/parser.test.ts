import { describe, it, expect, beforeEach, vi } from 'vitest'
import { OnboardJSParser } from './parser'
import type { OnboardingStep } from '@onboardjs/core'

describe('OnboardJSParser', () => {
    beforeEach(() => {
        // Clear any console spies/mocks before each test
        vi.clearAllMocks()
    })

    describe('parseSteps', () => {
        describe('TypeScript code with imports and type annotations', () => {
            it('should parse TypeScript code with imports, types, and export', () => {
                const tsCode = `// Generated by OnboardJS Flow Visualizer
// Export Date: 2025-09-08T14:49:30.940Z
// Total Steps: 6

import {
  OnboardingContext,
  OnboardingStep
} from '@onboardjs/core';

// Function definitions

// Condition function for step 'api-key-step'
const isSoftwareEngineer = (context: OnboardingContext) => context.flowData?.userRole === 'software-engineer';

// Condition function for step 'shop-showcase-step'
const isNotSoftwareEngineer = (context: OnboardingContext) => context.flowData?.userRole !== 'software-engineer';

// Onboarding Steps Configuration
export const onboardingSteps: OnboardingStep[] = [
  // Step 1: first-step
  {
    id: 'first-step',
    isSkippable: true,
    skipToStep: null,
  },

  // Step 2: persona-step
  {
    id: 'persona-step',
    previousStep: 'first-step',
  },

  // Step 3: api-key-step
  {
    id: 'api-key-step',
    nextStep: 'dev-resources-step',
    isSkippable: true,
    skipToStep: null,
    condition: isSoftwareEngineer,
  },

  // Step 4: dev-resources-step
  {
    id: 'dev-resources-step',
    nextStep: null,
  },

  // Step 5: shop-showcase-step
  {
    id: 'shop-showcase-step',
    nextStep: 'generation-step',
    condition: isNotSoftwareEngineer,
  },

  // Step 6: generation-step
  {
    id: 'generation-step',
    nextStep: null,
  }
] as const;`

                const steps = OnboardJSParser.parseSteps(tsCode)

                expect(steps).toHaveLength(6)

                // Check first step
                expect(steps[0]).toMatchObject({
                    id: 'first-step',
                    isSkippable: true,
                    skipToStep: null,
                })

                // Check step with previousStep
                expect(steps[1]).toMatchObject({
                    id: 'persona-step',
                    previousStep: 'first-step',
                })

                // Check step with condition function reference
                expect(steps[2]).toMatchObject({
                    id: 'api-key-step',
                    nextStep: 'dev-resources-step',
                    isSkippable: true,
                    skipToStep: null,
                })
                expect(steps[2].condition).toContain("context.flowData?.userRole === 'software-engineer'")

                // Check simple step
                expect(steps[3]).toMatchObject({
                    id: 'dev-resources-step',
                    nextStep: null,
                })

                // Check another condition step
                expect(steps[4]).toMatchObject({
                    id: 'shop-showcase-step',
                    nextStep: 'generation-step',
                })
                expect(steps[4].condition).toContain("context.flowData?.userRole !== 'software-engineer'")

                // Check final step
                expect(steps[5]).toMatchObject({
                    id: 'generation-step',
                    nextStep: null,
                })
            })
        })

        describe('JavaScript code without imports or types', () => {
            it('should parse plain JavaScript code', () => {
                const jsCode = `// Generated by OnboardJS Flow Visualizer
// Export Date: 2025-09-08T14:49:30.940Z
// Total Steps: 6

// Function definitions

// Condition function for step 'api-key-step'
const isSoftwareEngineer = (context) => context.flowData?.userRole === 'software-engineer';

// Condition function for step 'shop-showcase-step'
const isNotSoftwareEngineer = (context) => context.flowData?.userRole !== 'software-engineer';

// Onboarding Steps Configuration
export const onboardingSteps = [
  // Step 1: first-step
  {
    id: 'first-step',
    isSkippable: true,
    skipToStep: null,
  },

  // Step 2: persona-step
  {
    id: 'persona-step',
    previousStep: 'first-step',
  },

  // Step 3: api-key-step
  {
    id: 'api-key-step',
    nextStep: 'dev-resources-step',
    isSkippable: true,
    skipToStep: null,
    condition: isSoftwareEngineer,
  },

  // Step 4: dev-resources-step
  {
    id: 'dev-resources-step',
    nextStep: null,
  },

  // Step 5: shop-showcase-step
  {
    id: 'shop-showcase-step',
    nextStep: 'generation-step',
    condition: isNotSoftwareEngineer,
  },

  // Step 6: generation-step
  {
    id: 'generation-step',
    nextStep: null,
  }
];`

                const steps = OnboardJSParser.parseSteps(jsCode)

                expect(steps).toHaveLength(6)
                expect(steps[0].id).toBe('first-step')
                expect(steps[1].id).toBe('persona-step')
                expect(steps[2].id).toBe('api-key-step')
                expect(steps[3].id).toBe('dev-resources-step')
                expect(steps[4].id).toBe('shop-showcase-step')
                expect(steps[5].id).toBe('generation-step')

                // Verify conditions are properly extracted
                expect(steps[2].condition).toContain('software-engineer')
                expect(steps[4].condition).toContain('software-engineer')
            })
        })

        describe('code with inline functions', () => {
            it('should parse steps with inline condition functions', () => {
                const inlineFunctionCode = `
const steps = [
  {
    id: 'step1',
    condition: (context) => context.user?.role === 'admin'
  },
  {
    id: 'step2', 
    condition: (ctx) => ctx.flowData?.isComplete === true
  },
  {
    id: 'step3',
    nextStep: 'step4',
    condition: (context) => context.user?.permissions?.includes('edit')
  }
];`

                const steps = OnboardJSParser.parseSteps(inlineFunctionCode)

                expect(steps).toHaveLength(3)

                expect(steps[0]).toMatchObject({
                    id: 'step1',
                })
                expect(steps[0].condition).toContain("context.user?.role === 'admin'")

                expect(steps[1]).toMatchObject({
                    id: 'step2',
                })
                expect(steps[1].condition).toContain('ctx.flowData?.isComplete === true')

                expect(steps[2]).toMatchObject({
                    id: 'step3',
                    nextStep: 'step4',
                })
                expect(steps[2].condition).toContain('context.user?.permissions?.includes')
            })
        })

        describe('edge cases', () => {
            it('should handle complex condition functions and mixed references', () => {
                const edgeCaseCode = `
const steps = [
  {
    id: 'complex-condition',
    condition: (context) => {
      // Complex block function
      return context.user?.role === 'admin' && context.permissions?.length > 0
    }
  },
  {
    id: 'simple-boolean', 
    condition: (ctx) => true
  },
  {
    id: 'mixed-references',
    nextStep: null,
    isSkippable: true,
    condition: someFunction
  }
];

const someFunction = (context) => context.isReady;`

                const steps = OnboardJSParser.parseSteps(edgeCaseCode)

                expect(steps).toHaveLength(3)

                expect(steps[0].id).toBe('complex-condition')
                expect(steps[0].condition).toBeDefined()

                expect(steps[1].id).toBe('simple-boolean')
                expect(steps[1].condition).toContain('true')

                expect(steps[2]).toMatchObject({
                    id: 'mixed-references',
                    nextStep: null,
                    isSkippable: true,
                })
                expect(steps[2].condition).toContain('context.isReady')
            })

            it('should handle END references and convert them to null', () => {
                const codeWithEnd = `
const steps = [
  {
    id: 'step1',
    nextStep: 'null',
    previousStep: 'null',
    skipToStep: 'null'
  }
];`

                const steps = OnboardJSParser.parseSteps(codeWithEnd)

                expect(steps).toHaveLength(1)
                expect(steps[0]).toMatchObject({
                    id: 'step1',
                    nextStep: null,
                    previousStep: null,
                    skipToStep: null,
                })
            })

            it('should handle steps with meta information (title and description)', () => {
                const codeWithMeta = `
const steps = [
  {
    id: 'welcome',
    title: 'Welcome Step',
    description: 'This is the welcome step description'
  },
  {
    id: 'finish',
    title: 'Completion Step'
  }
];`

                const steps = OnboardJSParser.parseSteps(codeWithMeta)

                expect(steps).toHaveLength(2)
                expect(steps[0]).toMatchObject({
                    id: 'welcome',
                    meta: {
                        title: 'Welcome Step',
                        description: 'This is the welcome step description',
                    },
                })
                expect(steps[1]).toMatchObject({
                    id: 'finish',
                    meta: {
                        title: 'Completion Step',
                    },
                })
            })

            it('should handle steps with valid step types', () => {
                const codeWithTypes = `
const steps = [
  {
    id: 'info-step',
    type: 'INFORMATION'
  },
  {
    id: 'choice-step',
    type: 'MULTIPLE_CHOICE'
  },
  {
    id: 'confirm-step',
    type: 'CONFIRMATION'
  }
];`

                const steps = OnboardJSParser.parseSteps(codeWithTypes)

                expect(steps).toHaveLength(3)
                expect((steps[0] as any).type).toBe('INFORMATION')
                expect((steps[1] as any).type).toBe('MULTIPLE_CHOICE')
                expect((steps[2] as any).type).toBe('CONFIRMATION')
            })

            it('should ignore invalid step types', () => {
                const codeWithInvalidType = `
const steps = [
  {
    id: 'step1',
    type: 'INVALID_TYPE'
  }
];`

                const steps = OnboardJSParser.parseSteps(codeWithInvalidType)

                expect(steps).toHaveLength(1)
                expect(steps[0].id).toBe('step1')
                expect((steps[0] as any).type).toBeUndefined()
            })
        })

        describe('error handling and edge cases', () => {
            it('should return empty array for null/undefined input', () => {
                expect(OnboardJSParser.parseSteps(null as any)).toEqual([])
                expect(OnboardJSParser.parseSteps(undefined as any)).toEqual([])
                expect(OnboardJSParser.parseSteps('')).toEqual([])
            })

            it('should return empty array for non-string input', () => {
                expect(OnboardJSParser.parseSteps(123 as any)).toEqual([])
                expect(OnboardJSParser.parseSteps({} as any)).toEqual([])
                expect(OnboardJSParser.parseSteps([] as any)).toEqual([])
            })

            it('should handle malformed JavaScript gracefully', () => {
                const malformedCode = `
const steps = [
  {
    id: 'step1'
    // Missing comma
    nextStep: 'step2'
  }
];`

                const steps = OnboardJSParser.parseSteps(malformedCode)
                // The parser is resilient and can extract some data even from malformed JS using regex fallback
                expect(Array.isArray(steps)).toBe(true)
                if (steps.length > 0) {
                    expect(steps[0].id).toBe('step1')
                }
            })

            it('should handle code without step arrays', () => {
                const noStepsCode = `
const someVariable = 'hello';
function someFunction() {
  return 'world';
}`

                const steps = OnboardJSParser.parseSteps(noStepsCode)
                expect(steps).toEqual([])
            })

            it('should deduplicate steps with same ID', () => {
                const duplicateStepsCode = `
const steps = [
  { id: 'step1', nextStep: 'step2' },
  { id: 'step1', nextStep: 'step3' },
  { id: 'step2', nextStep: null }
];`

                const steps = OnboardJSParser.parseSteps(duplicateStepsCode)

                expect(steps).toHaveLength(2)
                expect(steps[0]).toMatchObject({
                    id: 'step1',
                    nextStep: 'step2',
                })
                expect(steps[1]).toMatchObject({
                    id: 'step2',
                    nextStep: null,
                })
            })

            it('should filter out invalid steps without ID', () => {
                const invalidStepsCode = `
const steps = [
  { nextStep: 'step2' }, // No ID
  { id: '', nextStep: 'step3' }, // Empty ID
  { id: '   ', nextStep: 'step4' }, // Whitespace ID
  { id: 'valid-step', nextStep: null } // Valid
];`

                const steps = OnboardJSParser.parseSteps(invalidStepsCode)

                expect(steps).toHaveLength(1)
                expect(steps[0]).toMatchObject({
                    id: 'valid-step',
                    nextStep: null,
                })
            })
        })

        describe('complex code structures', () => {
            it('should handle nested objects and arrays', () => {
                const complexCode = `
const config = {
  metadata: {
    version: '1.0.0'
  },
  steps: [
    {
      id: 'step1',
      data: {
        nested: ['array', 'values']
      }
    },
    {
      id: 'step2',
      nextStep: 'step3'
    }
  ]
};`

                const steps = OnboardJSParser.parseSteps(complexCode)

                expect(steps).toHaveLength(2)
                expect(steps[0].id).toBe('step1')
                expect(steps[1].id).toBe('step2')
            })

            it('should handle multiple step arrays in the same code', () => {
                const multipleArraysCode = `
const firstSteps = [
  { id: 'first1' },
  { id: 'first2' }
];

const secondSteps = [
  { id: 'second1' },
  { id: 'second2' }
];`

                const steps = OnboardJSParser.parseSteps(multipleArraysCode)

                // Should find steps from arrays with 'step' in the name
                expect(steps.length).toBeGreaterThan(0)
                const stepIds = steps.map((s) => s.id)
                expect(stepIds).toContain('first1')
                expect(stepIds).toContain('first2')
                expect(stepIds).toContain('second1')
                expect(stepIds).toContain('second2')
            })

            it('should handle template literals in step properties', () => {
                const templateLiteralCode = `
const steps = [
  {
    id: \`step-\${1}\`,
    title: \`Welcome Step\`
  }
];`

                const steps = OnboardJSParser.parseSteps(templateLiteralCode)

                // Template literals with expressions are complex to parse,
                // but we should at least not crash
                expect(Array.isArray(steps)).toBe(true)

                // If parsed successfully, check the content
                if (steps.length > 0) {
                    expect(steps[0].id).toBeDefined()
                    expect(typeof steps[0].id).toBe('string')
                }
            })
        })

        describe('condition function extraction', () => {
            it('should extract and map condition functions correctly', () => {
                const codeWithConditions = `
const isAdmin = (context) => context.user?.role === 'admin';
const hasPermissions = (ctx) => ctx.permissions?.length > 0;

const steps = [
  {
    id: 'admin-step',
    condition: isAdmin
  },
  {
    id: 'permission-step',
    condition: hasPermissions
  }
];`

                const steps = OnboardJSParser.parseSteps(codeWithConditions)

                expect(steps).toHaveLength(2)
                expect(steps[0].condition).toContain("context.user?.role === 'admin'")
                expect(steps[1].condition).toContain('ctx.permissions?.length > 0')
            })

            it('should handle TypeScript typed parameters in condition functions', () => {
                const tsConditionCode = `
const isUser = (context: OnboardingContext) => context.user?.type === 'user';
const isActive = (ctx: AppContext) => ctx.status === 'active';

const steps = [
  {
    id: 'user-step',
    condition: isUser
  },
  {
    id: 'active-step', 
    condition: isActive
  }
];`

                const steps = OnboardJSParser.parseSteps(tsConditionCode)

                expect(steps).toHaveLength(2)
                expect(steps[0].condition).toContain("context.user?.type === 'user'")
                expect(steps[1].condition).toContain("ctx.status === 'active'")
            })

            it('should handle missing condition function references', () => {
                const missingFunctionCode = `
const steps = [
  {
    id: 'step1',
    condition: unknownFunction
  }
];`

                const steps = OnboardJSParser.parseSteps(missingFunctionCode)

                expect(steps).toHaveLength(1)
                expect(steps[0].condition).toContain('Function reference: unknownFunction')
            })
        })

        describe('logging and console output', () => {
            it('should log info when using AST parser', () => {
                const consoleSpy = vi.spyOn(console, 'info').mockImplementation(() => {})

                // Code that will force AST parsing (no standard array pattern)
                const codeForAST = `
function createSteps() {
  return [
    { id: 'dynamic-step' }
  ];
}

const mySteps = createSteps();`

                OnboardJSParser.parseSteps(codeForAST)

                // The parser might use AST parsing for this case
                consoleSpy.mockRestore()
            })

            it('should handle parsing errors gracefully', () => {
                const consoleErrorSpy = vi.spyOn(console, 'error').mockImplementation(() => {})

                // This should trigger an error but still return empty array
                const invalidCode = 'invalid javascript syntax {'

                const steps = OnboardJSParser.parseSteps(invalidCode)

                expect(steps).toEqual([])

                consoleErrorSpy.mockRestore()
            })
        })
    })

    describe('performance and large inputs', () => {
        it('should handle large step arrays efficiently', () => {
            const largeSteps = Array.from(
                { length: 100 },
                (_, i) => `
  {
    id: 'step-${i}',
    nextStep: ${i < 99 ? `'step-${i + 1}'` : 'null'},
    title: 'Step ${i} Title'
  }`
            ).join(',')

            const largeCode = `
const steps = [${largeSteps}];`

            const start = Date.now()
            const steps = OnboardJSParser.parseSteps(largeCode)
            const duration = Date.now() - start

            expect(steps).toHaveLength(100)
            expect(duration).toBeLessThan(1000) // Should complete within 1 second
            expect(steps[0].id).toBe('step-0')
            expect(steps[99].id).toBe('step-99')
        })

        it('should handle complex nested structures without stack overflow', () => {
            const deeplyNested = `
const config = {
  level1: {
    level2: {
      level3: {
        level4: {
          level5: {
            steps: [
              { id: 'nested-step' }
            ]
          }
        }
      }
    }
  }
};`

            expect(() => {
                const steps = OnboardJSParser.parseSteps(deeplyNested)
                expect(Array.isArray(steps)).toBe(true)
            }).not.toThrow()
        })
    })
})
