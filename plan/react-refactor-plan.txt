# @onboardjs/react v1.0.0-rc.1 Implementation Plan

## Executive Summary

This document outlines the phased roadmap to address the architectural, performance, and reliability issues identified in the code review. The goal is to achieve a production-ready v1.0.0-rc.1 release that maintains backward compatibility while eliminating defensive programming patterns and strengthening type safety.

**Target Milestones:**
- Phase 1 (Weeks 1-2): Type Safety & Component Resolution
- Phase 2 (Weeks 2-3): Configuration & Initialization
- Phase 3 (Weeks 3-4): State Management Refinement
- Phase 4 (Week 4): Testing & Documentation
- Release: v1.0.0-rc.1

---

## Phase 1: Progress Status (Updated 2025-01-14)

**Overall Phase 1 Completion: 100% âœ…**

### Issue 1.1: Loose Component Resolution Typing - COMPLETE âœ…

#### Task 1.1.1 - Create Strict Component Type System âœ…
**Status:** COMPLETED
**Files Modified:** `packages/react/src/types/index.ts`

**Changes:**
- Added imports for all payload types from @onboardjs/core: `OnboardingStepType`, `InformationStepPayload`, `MultipleChoiceStepPayload`, `SingleChoiceStepPayload`, `ConfirmationStepPayload`, `CustomComponentStepPayload`, `ChecklistStepPayload`
- Created `StepComponentPropsMap<TContext>` discriminated union mapping each OnboardingStepType to its corresponding payload type
- Changed `StepComponent<P = any, TContext>` to `StepComponent<P = unknown, TContext>` (eliminates loose typing)
- Added `StepComponentByType<T extends OnboardingStepType, TContext>` for strict type-safe component assignment
- Updated `StepComponentRegistry<TContext>` from simple string-key record to: `{ [K in OnboardingStepType]?: StepComponentByType<K, TContext> } & Record<string | number, StepComponent<unknown, TContext>>`
- Enhanced JSDoc with comprehensive example showing type-safe component assignment

**Verification:**
- âœ… `StepComponentRegistry` properly constrains component types
- âœ… Consuming code gets proper type inference
- âœ… No `any` types in public registry APIs
- âœ… Custom string-keyed components still supported

#### Task 1.1.2 - Refactor useStepRenderer with Type-Safe Resolution âœ…
**Status:** COMPLETED
**Files Modified:** `packages/react/src/hooks/internal/useStepRenderer.tsx`

**Changes:**
- Added `resolveStepComponent<TContext>()` helper function with explicit three-tier priority:
  1. Check `step.component` property
  2. Check `componentRegistry[step.id]`
  3. Check `componentRegistry[step.type or componentKey]` (handles CUSTOM_COMPONENT)
- Added `isCallable()` type guard to validate resolved value is a React component (typeof value === 'function')
- Replaced loose undefined-checking with explicit null return from resolver
- Enhanced error UI: displays helpful HTML-formatted error message showing all attempted resolution paths
- Improved type safety: removed all `any` types from resolution logic

**Verification:**
- âœ… `resolveStepComponent()` function created with proper typing
- âœ… Type guards validate component callability
- âœ… Error messages include all attempted resolution paths
- âœ… Zero `any` types in resolution logic

### Issue 1.2: Analytics API Wrapping Adds No Value - COMPLETE âœ…

#### Task 1.2.1 - Remove Analytics from OnboardingContextValue âœ…
**Status:** COMPLETED
**Files Modified:** `packages/react/src/context/OnboardingProvider.tsx`, `packages/react/src/types/index.ts`

**Changes:**
- Removed entire `analytics: { trackEvent, flush, setUserId }` object from `OnboardingContextValue<TContext>` interface
- Removed ~30-line `analyticsApi` useMemo block that wrapped engine methods
- Removed `analytics: analyticsApi` from context value object literal
- Removed `analyticsApi` from memoization dependency array
- Context value now focuses on engine state and navigation actions only

**Rationale:**
- Unnecessary memoization layer (engine methods are already available)
- Single source of truth: consumers use `engine.trackCustomEvent()` directly
- Reduces cognitive load: no two APIs for same functionality

**Verification:**
- âœ… Analytics removed from `OnboardingContextValue` interface
- âœ… No compile errors after removal
- âœ… Context value properly memoized without analytics dependency

#### Task 1.2.2 - Update useOnboarding Hook âœ…
**Status:** COMPLETED
**Files Modified:** `packages/react/src/hooks/useOnboarding.tsx`

**Changes:**
- Removed `analytics` from contextValue destructuring
- Removed `analytics` from return object of `useOnboarding()` hook
- Updated hook to focus on core onboarding APIs only

**Verification:**
- âœ… `useOnboarding()` return type updated correctly
- âœ… Hook still provides all essential navigation and state management
- âœ… No breaking changes to other hook functionality

#### Task 1.2.3 - Ensure useOnboardingAnalytics Documentation âœ…
**Status:** COMPLETED
**Files Modified:** `packages/react/src/hooks/useOnboardingAnalytics.ts`

**Changes:**
- Enhanced JSDoc documentation to clearly state this is the primary hook for analytics operations
- Added example showing `trackAha()` usage
- Added example showing direct `engine.trackCustomEvent()` alternative for custom events
- Documented that analytics is no longer available through context
- Directed users to use `useOnboardingAnalytics()` for aha moment tracking

**Verification:**
- âœ… Hook is well-documented as primary analytics hook
- âœ… Examples provided for both aha moments and custom events
- âœ… Clear migration path documented for users

### Test Updates - COMPLETE âœ…
**Status:** VERIFIED
**Files Checked:** `packages/react/src/hooks/useOnboarding.test.tsx`

**Verification:**
- âœ… No references to analytics field in tests
- âœ… All existing tests still pass
- âœ… No test cleanup needed (afterEach spy cleanup already correct)

**Summary of Phase 1 Completion:**
- **Issue 1.1** (Loose Component Resolution Typing): 2/2 tasks complete
- **Issue 1.2** (Analytics API Wrapping): 3/3 tasks complete
- **Breaking Changes**: 1 (removing analytics from context)
- **Migration Required**: Users should switch from `context.analytics` to `useOnboardingAnalytics()` hook or direct `engine.trackCustomEvent()`

---


## Phase 1: Type Safety & Component Resolution (P0)

### Issue 1.1: Loose Component Resolution Typing

**Current Problem:**
- `StepComponent<any, TContext>` is too permissive
- No validation that resolved components match expected shape
- Runtime errors instead of compile-time safety
- Registry key handling assumes string types

**Tasks:**

#### 1.1.1 - Create Strict Component Type System
**File:** index.ts

```typescript
// Define discriminated union for step component props by type
type StepComponentPropsMap<TContext> = {
  INFORMATION: StepComponentProps<InformationStepPayload, TContext>
  SINGLE_CHOICE: StepComponentProps<SingleChoiceStepPayload, TContext>
  MULTIPLE_CHOICE: StepComponentProps<MultipleChoiceStepPayload, TContext>
  CONFIRMATION: StepComponentProps<ConfirmationStepPayload, TContext>
  CHECKLIST: StepComponentProps<ChecklistStepPayload<TContext>, TContext>
  CUSTOM_COMPONENT: StepComponentProps<CustomComponentStepPayload, TContext>
}

// Strict component type keyed by step type
type StepComponentByType<T extends OnboardingStepType, TContext> = 
  React.FC<StepComponentPropsMap<TContext>[T]>

// Registry with proper typing
export type StepComponentRegistry<TContext> = {
  [Key in OnboardingStepType]?: StepComponentByType<Key, TContext>
} & Record<string | number, React.FC<StepComponentProps<any, TContext>>>
```

**Why This Matters:**
- Consumers get autocomplete for component types
- TypeScript catches mismatched component/payload pairs
- Registry still supports string keys for custom components

**Acceptance Criteria:**
- [ ] `StepComponentRegistry` properly constrains component types
- [ ] Consuming code gets proper type inference
- [ ] No `any` types in public registry APIs

---

#### 1.1.2 - Refactor useStepRenderer with Type-Safe Resolution
**File:** useStepRenderer.tsx

**Current:**
```typescript
let ResolvedComponent: StepComponent<any, TContext> | undefined = /* loose resolution */
```

**New:**
```typescript
// Type-safe resolution that validates against step type
type ResolvedStepComponent<TContext> = React.ComponentType<StepComponentProps<any, TContext>>

function resolveComponent<TContext extends OnboardingContextType>(
  step: OnboardingStep<TContext>,
  componentRegistry?: StepComponentRegistry<TContext>
): ResolvedStepComponent<TContext> | null {
  // Resolution priority with validation at each step
  const candidate = 
    (step as any).component ??
    componentRegistry?.[step.id] ??
    componentRegistry?.[
      step.type === 'CUSTOM_COMPONENT' 
        ? (step.payload as Record<string, unknown>).componentKey 
        : step.type
    ]
  
  // Validate resolved component is callable
  if (candidate && typeof candidate === 'function') {
    return candidate
  }
  
  return null
}
```

**Why This Matters:**
- Eliminates the loose `StepComponent<any>` casting
- Clear validation before rendering
- Better error messages with type context

**Acceptance Criteria:**
- [ ] `resolveComponent()` function created with proper typing
- [ ] Type guards validate component callability
- [ ] Error messages include expected vs. actual types
- [ ] Zero `any` types in resolution logic

---

### Issue 1.2: Analytics API Wrapping Adds No Value

**Current Problem:**
- Thin wrapper around engine methods adds memoization overhead
- Consumers already have engine reference via `useOnboarding()`
- Creates confusion: two APIs for same functionality
- Dependency on `engine` and `isReady` causes unnecessary memoization

**Decision: Remove Analytics Wrapper from Context**

#### 1.2.1 - Remove Analytics from OnboardingContextValue
**File:** OnboardingProvider.tsx

**Current:**
```typescript
export interface OnboardingContextValue<TContext extends OnboardingContextType> {
  // ...
  analytics: {
    trackEvent: (eventName, properties?, options?) => void
    flush: () => Promise<void>
    setUserId: (userId) => void
  }
}
```

**New:**
```typescript
export interface OnboardingContextValue<TContext extends OnboardingContextType> {
  // Remove analytics entirely
  // Consumers use: engine.trackCustomEvent(), engine.flushAnalytics(), engine.setAnalyticsUserId()
}
```

#### 1.2.2 - Update useOnboarding Hook
**File:** useOnboarding.tsx

Remove the analytics field from destructuring and return value. This forces consumers to understand they're using the engine directly.

#### 1.2.3 - Add Helper Hook useOnboardingAnalytics (Already Exists)
**File:** useOnboardingAnalytics.ts

Ensure this hook is well-documented as the primary way to access analytics:

```typescript
/**
 * Hook for tracking aha moments and custom analytics events.
 * 
 * This hook provides a convenient way to track events with automatic
 * engine context, user ID detection, and flow information.
 * 
 * @example
 * ```tsx
 * const { trackAha } = useOnboardingAnalytics()
 * 
 * const handleFeatureDiscover = async () => {
 *   await trackAha({
 *     aha_type: 'feature_discovery',
 *     journey_stage: 'adoption'
 *   })
 * }
 * ```
 */
export function useOnboardingAnalytics<TContext extends OnboardingContextType>() { ... }
```

**Why This Matters:**
- Removes unnecessary memoization
- Single source of truth: use the engine
- Clearer API surface
- Customers don't need to learn two APIs

**Acceptance Criteria:**
- [ ] Analytics removed from `OnboardingContextValue`
- [ ] `useOnboarding()` return type updated
- [ ] `useOnboardingAnalytics()` documented as primary analytics hook
- [ ] Breaking change noted in CHANGELOG
- [ ] Migration guide added to README

---

## Phase 2: Configuration & Initialization (P0)

### Issue 2.1: Memoization Over-Complexity

**Current Problem:**
- 15-dependency memoization array is fragile
- Dependencies change frequently, causing re-initialization
- Config validation happens in `useEffect`, not at instantiation
- Defensive pattern suggests uncertainty in engine's re-initialization handling

**Strategy:** Lean on the Engine, Trust the Hash

#### 2.1.1 - Simplify engineConfig Memoization
**File:** OnboardingProvider.tsx

**Current:**
```typescript
const engineConfig: OnboardingEngineConfig<TContext> = useMemo(
  () => ({
    steps, plugins, initialStepId, initialContext,
    onFlowComplete: onFlowCompleteHandler, onStepChange, loadData: onDataLoad,
    persistData: onDataPersist, clearPersistedData: onClearPersistedData,
    debug, flowId, flowName, flowVersion, flowMetadata,
    publicKey, apiHost, cloudOptions, analytics, userId,
  }),
  [steps, plugins, initialStepId, initialContext, /* ... 15 deps ... */]
)
```

**New (Two-Tier Approach):**

```typescript
// Tier 1: Structural config (triggers engine re-creation)
const structuralConfig = useMemo(() => ({
  steps,
  initialStepId,
  initialContext,
  debug,
  plugins: plugins || [],
}), [steps, initialStepId, initialContext, debug, plugins])

// Tier 2: Behavioral config (passed via callbacks, doesn't re-create engine)
const behavioralConfig = useMemo(() => ({
  onFlowComplete: onFlowCompleteHandler,
  onStepChange,
  loadData: onDataLoad,
  persistData: onDataPersist,
  clearPersistedData: onClearPersistedData,
}), [
  onFlowCompleteHandler,
  onStepChange,
  onDataLoad,
  onDataPersist,
  onClearPersistedData,
])

// Tier 3: Cloud/Analytics config (merged into engine after ready)
const cloudConfig = useMemo(() => ({
  flowId, flowName, flowVersion, flowMetadata,
  publicKey, apiHost, cloudOptions, analytics, userId,
}), [flowId, flowName, flowVersion, flowMetadata, publicKey, apiHost, cloudOptions, analytics, userId])

const engineConfig: OnboardingEngineConfig<TContext> = useMemo(() => ({
  ...structuralConfig,
  ...behavioralConfig,
  ...cloudConfig,
}), [structuralConfig, behavioralConfig, cloudConfig])
```

**Why This Matters:**
- Reduces cognitive load: you can see which config changes trigger what
- Engine re-creation only happens for structural changes
- Behavioral callbacks can change without side effects
- Each tier has a clear responsibility

**Acceptance Criteria:**
- [ ] Three-tier config structure implemented
- [ ] Dependency arrays reduced to 3-5 dependencies each
- [ ] Engine lifecycle tests confirm no unnecessary re-initialization
- [ ] Performance regression tests still pass

---

#### 2.1.2 - Move Configuration Validation to Provider Constructor-Time
**File:** OnboardingProvider.tsx

**Current (useEffect in useEngineLifecycle):**
```typescript
useEffect(() => {
  const validation = ConfigurationBuilder.validateConfig(currentConfig)
  if (!validation.isValid) {
    setError(validationError)
    return
  }
  // create engine
}, [configHash])
```

**New (Provider-level validation):**

```typescript
export function OnboardingProvider<TContext extends OnboardingContextType>({
  children,
  steps,
  // ... other props
}: OnboardingProviderProps<TContext>) {
  // Validate immediately, before any renders
  const validation = useMemo(() => {
    return ConfigurationBuilder.validateConfig({
      steps,
      initialStepId,
      initialContext,
      plugins,
      debug,
    })
  }, [steps, initialStepId, initialContext, plugins, debug])

  if (!validation.isValid) {
    // Fail fast: throw error or return error boundary
    throw new Error(
      `[OnboardJS] Invalid Onboarding Configuration:\n${validation.errors.join('\n')}`
    )
  }

  if (validation.warnings.length > 0 && debug) {
    console.warn('[OnboardJS] Configuration warnings:', validation.warnings)
  }

  // Only proceed if valid
  // ...
}
```

**Why This Matters:**
- Errors surface during provider instantiation, not async
- Clearer error handling: fast failure vs. async state
- Aligns with engine's philosophy of failing fast
- Type-level validation happens before runtime

**Acceptance Criteria:**
- [ ] `OnboardingProvider` validates config before render
- [ ] Invalid config throws immediately
- [ ] Warnings logged only in debug mode
- [ ] Test: invalid config fails at provider creation, not render

---

### Issue 2.2: Configuration Validation Happens in useEffect

**Handled by Issue 2.1.2 above** âœ“

---

## Phase 3: State Management Refinement (P1)

### Issue 3.1: Loose Loading State Composition

**Current Problem:**
```typescript
const isLoading = 
  componentLoading || 
  (engineState?.isLoading ?? false) || 
  (engineState?.isHydrating ?? false)
```

Consumers don't know *why* UI is blocked. Three sources of truth, unclear semantics.

#### 3.1.1 - Expose Individual Loading States
**File:** OnboardingProvider.tsx

**Update OnboardingContextValue:**
```typescript
export interface OnboardingContextValue<TContext extends OnboardingContextType> {
  // Existing fields...
  
  // Explicit loading state breakdown (new)
  loading: {
    /** Engine is initializing from persisted data */
    isHydrating: boolean
    /** Engine is executing async operations (navigation, persistence, etc.) */
    isEngineProcessing: boolean
    /** Current step component is validating or fetching data */
    isComponentProcessing: boolean
    /** Any of the above: convenient for "disable UI" logic */
    isAnyLoading: boolean
  }

  // Deprecated (v1.0-rc.1) - kept for backward compatibility, marked as deprecated
  isLoading: boolean // maps to loading.isAnyLoading
}
```

**Rationale:**
- Consumers can distinguish between hydration, engine ops, and component ops
- Better UX: show different UI states for different loading scenarios
- `isLoading` still available as alias for backward compatibility
- Proper deprecation path to v1.0 final

#### 3.1.2 - Implement getLoadingReason() Utility
**File:** `src/utils/loadingState.ts` (new)

```typescript
export type LoadingReason = 
  | 'hydrating'
  | 'navigating'
  | 'persisting'
  | 'component-validating'
  | 'component-fetching'
  | null

export function getLoadingReason(loading: LoadingState): LoadingReason {
  if (loading.isHydrating) return 'hydrating'
  if (loading.isEngineProcessing) return 'navigating' // or 'persisting'
  if (loading.isComponentProcessing) return 'component-validating' // or 'component-fetching'
  return null
}
```

Consumers can now do:
```typescript
const reason = getLoadingReason(loading)
if (reason === 'hydrating') {
  return <SkeletonLoader /> // Initial data load
} else if (reason === 'navigating') {
  return <StepTransition /> // Navigation in progress
} else if (reason === 'component-validating') {
  return <ValidationSpinner /> // Form validation
}
```

**Acceptance Criteria:**
- [ ] `OnboardingContextValue.loading` object created with 4 properties
- [ ] `isLoading` aliased to `loading.isAnyLoading` for backward compat
- [ ] `getLoadingReason()` utility exported
- [ ] Provider sets individual loading states correctly
- [ ] Tests verify loading state combinations
- [ ] Deprecation notice in JSDoc for `isLoading`

---

#### 3.1.3 - Update useEngineActions to Set Component Processing State
**File:** useEngineActions.ts

**Current:**
```typescript
const next = useCallback(async (overrideData?: Record<string, unknown>) => {
  onLoadingChange(true) // Unclear what this means
  try {
    await engine.next(dataToPass)
  } finally {
    onLoadingChange(false)
  }
}, [/* deps */])
```

**New:**
```typescript
const next = useCallback(
  async (overrideData?: Record<string, unknown>) => {
    if (!engine || !isEngineReady) return

    // Set engine processing state (not component state)
    onEngineProcessingChange(true)
    try {
      await engine.next(dataToPass)
    } finally {
      onEngineProcessingChange(false)
    }
  },
  [engine, isEngineReady, stepData, onEngineProcessingChange]
)
```

**Why This Matters:**
- Separates component state from engine state
- Components set `isComponentProcessing` via `setComponentLoading()`
- Engine actions set `isEngineProcessing` via `onEngineProcessingChange()`
- Clear semantics

**Acceptance Criteria:**
- [ ] `onEngineProcessingChange` callback passed to `useEngineActions`
- [ ] All engine action methods use engine processing state
- [ ] Tests verify correct state transitions

---

### Issue 3.2: Ref Usage Pattern (Unnecessary configRef)

**Current Problem:**
```typescript
const configRef = useRef(config)
configRef.current = config
// Then used in effect to read latest config
```

This is unnecessary since React captures latest values in effect cleanup.

#### 3.2.1 - Remove Unnecessary configRef
**File:** useEngineLifecycle.ts

**Current:**
```typescript
const configRef = useRef(config)
configRef.current = config

useEffect(() => {
  const currentConfig = configRef.current
  // use currentConfig
}, [configHash])
```

**New:**
```typescript
useEffect(() => {
  // Use config directly from closure
  const validation = ConfigurationBuilder.validateConfig(config)
  // ...
}, [configHash])
```

**Why This Matters:**
- Simpler code: one less ref to maintain
- React already handles closure capture correctly
- Reduces confusion for future maintainers

**Acceptance Criteria:**
- [ ] `configRef` removed from `useEngineLifecycle`
- [ ] `isMountedRef` retained (necessary for cleanup)
- [ ] All tests pass
- [ ] No functional changes

---

### Issue 3.3: Test Cleanup Bug (afterEach Missing)

**Current Problem:**
In useOnboarding.test.tsx, the console.error spy cleanup happens in the test, not afterEach:

```typescript
it('should throw error when used outside OnboardingProvider', () => {
  const consoleErrorSpy = vi.spyOn(console, 'error').mockImplementation(() => {})
  expect(() => { /* ... */ }).toThrow()
  consoleErrorSpy.mockRestore() // If test fails, spy remains!
})
```

#### 3.3.1 - Move Spy Cleanup to afterEach
**File:** useOnboarding.test.tsx

**New:**
```typescript
describe('useOnboarding', () => {
  let consoleErrorSpy: ReturnType<typeof vi.spyOn>

  beforeEach(() => {
    consoleErrorSpy = vi.spyOn(console, 'error').mockImplementation(() => {})
  })

  afterEach(() => {
    consoleErrorSpy?.mockRestore() // Safe cleanup
    vi.clearAllMocks()
  })

  it('should throw error when used outside OnboardingProvider', () => {
    expect(() => {
      renderHook(() => useOnboarding())
    }).toThrow('useOnboarding must be used within an OnboardingProvider')
  })

  // ... more tests
})
```

**Acceptance Criteria:**
- [ ] Spy cleanup moved to `afterEach()`
- [ ] Safe null-check in cleanup
- [ ] All tests pass
- [ ] No spy leakage between tests

---

## Phase 4: Testing & Documentation (P1)

### Issue 4.1: Missing Test Coverage for Critical Paths

#### 4.1.1 - Add Configuration Change Tests
**File:** `src/hooks/internal/useEngineLifecycle.test.ts` (new)

```typescript
describe('useEngineLifecycle - Configuration Changes', () => {
  it('should recreate engine when steps array structure changes', async () => {
    // Render with step array: [step1, step2]
    // Verify engine instanceId
    
    // Re-render with new step array: [step1, step2, step3]
    // Verify engine instanceId changed
  })

  it('should NOT recreate engine when callback reference changes', async () => {
    // Render with onFlowComplete callback
    // Verify engine instanceId
    
    // Re-render with different onFlowComplete reference
    // Verify engine instanceId unchanged (same instance)
  })

  it('should properly re-register listeners on engine recreation', async () => {
    // Setup listeners on initial engine
    // Trigger engine recreation via config change
    // Verify old listeners removed
    // Verify new listeners registered
  })

  it('should handle config validation errors gracefully', async () => {
    // Render with invalid config
    // Verify error state is set
    // Verify engine is null
    // Verify error message is clear
  })
})
```

**Acceptance Criteria:**
- [ ] 4+ test cases for configuration changes
- [ ] Engine re-creation behavior verified
- [ ] Listener re-registration tested
- [ ] Error handling tested

---

#### 4.1.2 - Add Component Resolution Tests
**File:** `src/hooks/internal/useStepRenderer.test.tsx` (new)

```typescript
describe('useStepRenderer - Component Resolution', () => {
  it('should resolve component by step.component property first', () => {
    // Create step with component property
    // Verify resolved component matches property
  })

  it('should resolve component by step.id from registry', () => {
    // Create registry with step ID key
    // Verify resolved component matches registry entry
  })

  it('should resolve component by step.type from registry', () => {
    // Create registry with step type key
    // Verify resolved component matches type entry
  })

  it('should resolve CUSTOM_COMPONENT by payload.componentKey', () => {
    // Create CUSTOM_COMPONENT step
    // Verify componentKey resolution
  })

  it('should return error component when no component found', () => {
    // Create step with no matching component
    // Verify error message rendered
    // Verify error includes all attempted resolution paths
  })

  it('should validate resolved component is callable', () => {
    // Mock non-callable registry entry (string, object, etc.)
    // Verify validation fails gracefully
  })

  it('should pass correct props to resolved component', () => {
    // Create mock component that captures props
    // Render step with various payloads
    // Verify props match StepComponentProps interface
  })
})
```

**Acceptance Criteria:**
- [ ] 7+ test cases for component resolution
- [ ] All resolution paths covered
- [ ] Error cases tested
- [ ] Props passing verified

---

#### 4.1.3 - Add Loading State Tests
**File:** `src/context/OnboardingProvider.test.tsx` (expand existing)

```typescript
describe('Loading State Management', () => {
  it('should distinguish hydration loading from engine processing', async () => {
    // Render provider
    // During initial load: isHydrating=true, isEngineProcessing=false
    // After load: isHydrating=false
  })

  it('should set isEngineProcessing during navigation', async () => {
    // Render provider with hook
    // Call next()
    // Verify isEngineProcessing=true during async operation
    // Verify isEngineProcessing=false after completion
  })

  it('should set isComponentProcessing when component reports loading', async () => {
    // Component calls setComponentLoading(true)
    // Verify isComponentProcessing=true
    // Component calls setComponentLoading(false)
    // Verify isComponentProcessing=false
  })

  it('should correctly compute isAnyLoading from individual states', () => {
    // Verify isAnyLoading = true if any sub-state is true
    // Verify isAnyLoading = false if all sub-states are false
  })
})
```

**Acceptance Criteria:**
- [ ] 4+ test cases for loading states
- [ ] Hydration, engine, and component states tested
- [ ] State combinations verified
- [ ] isLoading backward compat verified

---

### Issue 4.2: Documentation Gaps

#### 4.2.1 - Create IMPLEMENTATION_GUIDE.md
**File:** `IMPLEMENTATION_GUIDE.md` (new in packages/react/)

```markdown
# Implementation Guide for @onboardjs/react v1.0.0-rc.1

## Major Changes from v0.5.x

### Analytics API Moved (Breaking Change)

**Before (v0.5.x):**
```typescript
const { analytics } = useOnboarding()
analytics.trackEvent('my-event', { foo: 'bar' })
```

**After (v1.0-rc.1):**
```typescript
const { engine } = useOnboarding()
engine.trackCustomEvent('my-event', { foo: 'bar' })

// Or use the dedicated hook:
const { trackAha } = useOnboardingAnalytics()
await trackAha({ aha_type: 'feature_discovery' })
```

### Loading State Granularity

**Before:**
```typescript
const { isLoading } = useOnboarding()
// Unclear why: hydrating? navigating? validating?
```

**After:**
```typescript
const { loading } = useOnboarding()

if (loading.isHydrating) {
  return <InitialLoadScreen />
} else if (loading.isEngineProcessing) {
  return <NavigationSpinner />
} else if (loading.isComponentProcessing) {
  return <ValidationSpinner />
}

// Or use the helper:
const reason = getLoadingReason(loading)
```

## Type Safety Improvements

### Component Registry Typing

Components in the registry are now properly typed:

```typescript
const registry: StepComponentRegistry = {
  welcome: (props) => {
    // props is StepComponentProps<CustomComponentStepPayload>
    // No more `any` typing!
  },
  INFORMATION: (props) => {
    // props is StepComponentProps<InformationStepPayload>
  },
}
```

## Configuration Management

Configuration validation now happens at provider creation, not async:

```typescript
try {
  const engine = (
    <OnboardingProvider steps={steps} ... >
      <App />
    </OnboardingProvider>
  )
} catch (error) {
  // Invalid config caught immediately
  console.error('Invalid onboarding config:', error.message)
}
```

## Migration Checklist

- [ ] Update analytics calls from `analytics.trackEvent()` to `engine.trackCustomEvent()`
- [ ] Update aha moment tracking to use `useOnboardingAnalytics()`
- [ ] Review loading state logic and use new `loading` object
- [ ] Update component registry typing to remove `any`
- [ ] Test configuration validation in your setup
```

**Acceptance Criteria:**
- [ ] Migration guide covers all breaking changes
- [ ] Before/after code examples provided
- [ ] Checklist included
- [ ] Clear explanation of new APIs

---

#### 4.2.2 - Update README.md with API Changes
**File:** `README.md`

Add section:
```markdown
## v1.0.0-rc.1 Changes

This release includes breaking changes to improve type safety and reduce defensive programming:

1. **Analytics API Removed from Context** - Use `engine.trackCustomEvent()` or `useOnboardingAnalytics()`
2. **Loading State Granularity** - Replace `isLoading` with `loading` object
3. **Type-Safe Component Resolution** - Registry now properly typed by step type
4. **Configuration Validation at Provider Creation** - Errors surface immediately, not async

See [IMPLEMENTATION_GUIDE.md](./IMPLEMENTATION_GUIDE.md) for migration details.
```

**Acceptance Criteria:**
- [ ] Breaking changes documented in README
- [ ] Link to implementation guide
- [ ] Clear migration path outlined

---

#### 4.2.3 - Update JSDoc Comments
**File:** Multiple (useOnboarding.tsx, OnboardingProvider.tsx, etc.)

```typescript
/**
 * Hook to access the onboarding engine and state.
 * 
 * Provides engine reference, current state, navigation methods, and loading state.
 * 
 * @example
 * ```tsx
 * const { engine, state, next, loading } = useOnboarding()
 * 
 * // Navigate to next step
 * await next({ userChoice: 'option1' })
 * 
 * // Track custom event
 * engine.trackCustomEvent('my-event', { feature: 'x' })
 * 
 * // Check loading state
 * if (loading.isHydrating) return <LoadScreen />
 * ```
 * 
 * @throws {Error} If used outside OnboardingProvider
 */
export function useOnboarding<TContext extends OnboardingContextType>() { ... }
```

**Acceptance Criteria:**
- [ ] All exported functions have comprehensive JSDoc
- [ ] Examples demonstrate new APIs
- [ ] Breaking changes noted where relevant
- [ ] Return types clearly documented

---

## Phase 5: Release & Validation (Week 5)

### Task 5.1 - Update package.json and CHANGELOG

**File:** package.json
```json
{
  "version": "1.0.0-rc.1"
}
```

**File:** `CHANGELOG.md` (new)
```markdown
# Changelog

## [1.0.0-rc.1] - 2025-01-XX

### Breaking Changes

- **Analytics API removed from context**: Use `engine.trackCustomEvent()` or `useOnboardingAnalytics()` hook instead
- **Loading state restructured**: Replace `isLoading` with `loading` object containing `isHydrating`, `isEngineProcessing`, `isComponentProcessing`, `isAnyLoading`
- **Component registry typing improved**: Registry now properly typed by step type; less flexible but type-safe

### Improvements

- **Type Safety**: Component resolution now strongly typed, eliminates `any` typing
- **Loading State**: Granular loading state allows distinguishing hydration, navigation, and validation
- **Configuration Validation**: Validation happens at provider creation, failing fast instead of async
- **Reduced Memoization**: Simplified dependency arrays by tiering config
- **Test Coverage**: Added comprehensive tests for component resolution, config changes, and loading states

### Deprecated

- `OnboardingContextValue.isLoading` - Use `loading.isAnyLoading` instead

### Documentation

- Added `IMPLEMENTATION_GUIDE.md` with migration instructions
- Enhanced JSDoc comments with examples
- Updated README with v1.0-rc.1 changes

### Fixed

- Test spy cleanup now in `afterEach()` instead of individual tests
- Removed unnecessary `configRef` from `useEngineLifecycle`
```

---

### Task 5.2 - Run Full Test Suite & Coverage

```bash
# Run all tests
pnpm test:run

# Check coverage
pnpm test:coverage

# Type check
pnpm check-types

# Lint
pnpm lint

# Build
pnpm build
```

**Acceptance Criteria:**
- [ ] All tests pass (â‰¥95% coverage target)
- [ ] No type errors
- [ ] No lint errors
- [ ] Build successful
- [ ] Types correctly exported

---

### Task 5.3 - Integration Testing

Create `e2e.test.tsx` (new):
```typescript
describe('End-to-End Integration', () => {
  it('should complete full onboarding flow with v1.0-rc.1 APIs', async () => {
    // Full flow: provider setup â†’ navigation â†’ analytics â†’ completion
    // Verify all new APIs work together
  })

  it('should handle backward compat (isLoading)', async () => {
    // Verify isLoading still works (maps to loading.isAnyLoading)
  })

  it('should fail gracefully with invalid config', async () => {
    // Invalid config caught at provider creation
  })
})
```

**Acceptance Criteria:**
- [ ] E2E test covering full flow
- [ ] Backward compatibility verified
- [ ] Error handling validated

---

### Task 5.4 - Manual Testing Checklist

- [ ] Test in React 18 app
- [ ] Test in React 19 app
- [ ] Test in Next.js 14+ app
- [ ] Test with TypeScript strict mode
- [ ] Test with `@onboardjs/core` v0.3.12+
- [ ] Manual analytics tracking
- [ ] Manual error scenarios
- [ ] Verify no console warnings (only errors)

---

## Implementation Priority & Dependencies

### Critical Path (Must Complete):
1. âœ… Issue 2.1.2 - Config validation timing
2. âœ… Issue 1.1 - Component type safety
3. âœ… Issue 3.1 - Loading state breakdown
4. âœ… Issue 1.2 - Remove analytics from context

### High Priority (Should Complete):
5. âœ… Issue 2.1.1 - Simplify memoization
6. âœ… Issue 3.2 - Remove configRef
7. âœ… Issue 4.1 - Add test coverage

### Medium Priority (Nice to Have):
8. âœ… Issue 3.3 - Fix test cleanup
9. âœ… Issue 4.2 - Documentation
10. âœ… Phase 5 - Release tasks

---

## Risk Assessment & Mitigation

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|-----------|
| Breaking change breaks existing apps | High | High | Comprehensive migration guide, beta period, sample apps |
| Type changes cause downstream issues | Medium | Medium | Thorough testing, type coverage > 95% |
| Performance regression | Low | Medium | Performance regression tests, benchmarking |
| Documentation insufficient | Medium | Medium | Multiple docs, examples, e2e tests |

---

## Definition of Done

A task is complete when:

- âœ… Code changes implemented and reviewed
- âœ… All tests pass (existing + new)
- âœ… Type-safe (no `any` types unless documented exception)
- âœ… No ESLint errors
- âœ… JSDoc comments updated
- âœ… No performance regressions
- âœ… Backward compatibility assessed (breaking changes documented)
- âœ… Integration tested

---

## Success Metrics for v1.0.0-rc.1

- âœ… **Code Quality**: Zero `any` in public APIs, TypeScript strict mode passes
- âœ… **Test Coverage**: >95% coverage, critical paths tested
- âœ… **Type Safety**: Component registry fully typed
- âœ… **Performance**: Engine instantiation stable, no unnecessary re-renders
- âœ… **Documentation**: Migration guide, API docs, examples
- âœ… **Backward Compatibility**: Clear deprecation paths, isLoading alias works
- âœ… **Release Readiness**: CHANGELOG, updated README, package.json version bump

---

## Timeline Estimate

| Phase | Duration | Effort |
|-------|----------|--------|
| Phase 1 (Type Safety) | 4-5 days | 12-16 hrs |
| Phase 2 (Config) | 3-4 days | 8-12 hrs |
| Phase 3 (State) | 3-4 days | 8-12 hrs |
| Phase 4 (Testing & Docs) | 2-3 days | 8-12 hrs |
| Phase 5 (Release & QA) | 2-3 days | 6-10 hrs |
| **Total** | **~3 weeks** | **~42-62 hrs** |

**Target Release Date:** Mid-January 2025

---

## Sign-Off

This plan provides a clear roadmap to elevate @onboardjs/react from "competent but defensive" to "production-ready and type-safe v1.0.0-rc.1."

The changes are strategic: they eliminate uncertainty, reduce memoization complexity, and dramatically improve type safety without breaking the fundamental architecture.

Now go make it happen. ðŸ”¥
